<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Friends Management</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
    }

    .header {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      padding: 30px;
      text-align: center;
      position: relative;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
    }

    .header p {
      opacity: 0.9;
      font-size: 1.1rem;
    }

    .connection-status {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .connection-status.connected {
      background: rgba(40, 167, 69, 0.9);
      color: white;
    }

    .connection-status.disconnected {
      background: rgba(220, 53, 69, 0.9);
      color: white;
    }

    .connection-status.connecting {
      background: rgba(255, 193, 7, 0.9);
      color: #212529;
    }

    .tabs {
      display: flex;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
    }

    .tab {
      flex: 1;
      padding: 15px 20px;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      color: #6c757d;
      transition: all 0.3s ease;
      position: relative;
    }

    .tab.active {
      color: #667eea;
      background: white;
    }

    .tab.active::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: #667eea;
    }

    .tab:hover:not(.active) {
      background: #e9ecef;
      color: #495057;
    }

    .tab-content {
      display: none;
      padding: 30px;
      min-height: 500px;
    }

    .tab-content.active {
      display: block;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 2px solid #e9ecef;
    }

    .section-title {
      font-size: 1.5rem;
      color: #495057;
      font-weight: 600;
    }

    .search-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .search-input {
      padding: 10px 15px;
      border: 2px solid #dee2e6;
      border-radius: 25px;
      outline: none;
      font-size: 14px;
      min-width: 200px;
      transition: border-color 0.3s ease;
    }

    .search-input:focus {
      border-color: #667eea;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-primary {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }

    .btn-success {
      background: linear-gradient(45deg, #28a745, #20c997);
      color: white;
    }

    .btn-success:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
    }

    .btn-danger {
      background: linear-gradient(45deg, #dc3545, #e83e8c);
      color: white;
    }

    .btn-danger:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(220, 53, 69, 0.3);
    }

    .btn-warning {
      background: linear-gradient(45deg, #ffc107, #fd7e14);
      color: #212529;
    }

    .btn-warning:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 193, 7, 0.3);
    }

    .btn-secondary {
      background: linear-gradient(45deg, #6c757d, #495057);
      color: white;
    }

    .btn-secondary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(108, 117, 125, 0.3);
    }

    .btn-info {
      background: linear-gradient(45deg, #17a2b8, #138496);
      color: white;
    }

    .btn-info:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(23, 162, 184, 0.3);
    }

    .user-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .user-card {
      background: white;
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }

    .user-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0,0,0,0.15);
      border-color: #667eea;
    }

    .user-card.new-notification {
      animation: pulseGlow 2s ease-in-out;
    }

    @keyframes pulseGlow {
      0%, 100% { 
        border-color: transparent; 
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      }
      50% { 
        border-color: #28a745; 
        box-shadow: 0 0 20px rgba(40, 167, 69, 0.3);
      }
    }

    .user-info {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
    }

    .user-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(45deg, #667eea, #764ba2);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 18px;
      margin-right: 15px;
    }

    .user-details h3 {
      font-size: 1.2rem;
      color: #495057;
      margin-bottom: 5px;
    }

    .user-details p {
      color: #6c757d;
      font-size: 14px;
    }

    .user-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #6c757d;
    }

    .empty-state h3 {
      font-size: 1.5rem;
      margin-bottom: 10px;
      color: #495057;
    }

    .empty-state p {
      font-size: 1rem;
      line-height: 1.5;
    }

    .loading {
      text-align: center;
      padding: 40px;
    }

    .spinner {
      display: inline-block;
      width: 40px;
      height: 40px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 20px;
      border-radius: 10px;
      color: white;
      font-weight: 600;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 1000;
      max-width: 300px;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.success {
      background: linear-gradient(45deg, #28a745, #20c997);
    }

    .notification.error {
      background: linear-gradient(45deg, #dc3545, #e83e8c);
    }

    .notification.info {
      background: linear-gradient(45deg, #17a2b8, #138496);
    }

    .notification.websocket {
      background: linear-gradient(45deg, #6f42c1, #e83e8c);
    }

    .status-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-accepted {
      background: #d4edda;
      color: #155724;
    }

    .status-pending {
      background: #fff3cd;
      color: #856404;
    }

    .status-blocked {
      background: #f8d7da;
      color: #721c24;
    }

    .status-available {
      background: #cce5ff;
      color: #004085;
    }

    .status-requested {
      background: #e2e3e5;
      color: #383d41;
    }

    @media (max-width: 768px) {
      .container {
        margin: 10px;
        border-radius: 15px;
      }
      
      .user-grid {
        grid-template-columns: 1fr;
      }
      
      .tabs {
        flex-direction: column;
      }
      
      .search-controls {
        flex-direction: column;
        gap: 15px;
      }
      
      .search-input {
        min-width: 100%;
      }

      .connection-status {
        position: static;
        margin: 10px auto;
        display: inline-block;
      }
    }
  </style>
</head>
<body>

<div class="container">
  <div class="header">
    <div id="connectionStatus" class="connection-status connecting">
      üîÑ Connecting...
    </div>
    <h1>üë• Friends Management</h1>
    <p>Connect, manage, and organize your social network</p>
  </div>

  <div class="tabs">
    <button class="tab active" onclick="switchTab('friends')">
      ü§ù My Friends
    </button>
    <button class="tab" onclick="switchTab('pending')">
      ‚è≥ Pending Requests
    </button>
    <button class="tab" onclick="switchTab('blocked')">
      üö´ Blocked Users
    </button>
    <button class="tab" onclick="switchTab('search')">
      üîç Find Friends
    </button>
  </div>

  <!-- Friends Tab -->
  <div id="friends" class="tab-content active">
    <div class="section-header">
      <h2 class="section-title">My Friends</h2>
    </div>
    <div id="friends-loading" class="loading">
      <div class="spinner"></div>
      <p>Loading your friends...</p>
    </div>
    <div id="friends-list" class="user-grid" style="display: none;"></div>
    <div id="friends-empty" class="empty-state" style="display: none;">
      <h3>No Friends Yet</h3>
      <p>Start connecting with people by sending friend requests!</p>
    </div>
  </div>

  <!-- Pending Requests Tab -->
  <div id="pending" class="tab-content">
    <div class="section-header">
      <h2 class="section-title">Pending Friend Requests</h2>
    </div>
    <div id="pending-loading" class="loading">
      <div class="spinner"></div>
      <p>Loading pending requests...</p>
    </div>
    <div id="pending-list" class="user-grid" style="display: none;"></div>
    <div id="pending-empty" class="empty-state" style="display: none;">
      <h3>No Pending Requests</h3>
      <p>You're all caught up! No pending friend requests at the moment.</p>
    </div>
  </div>

  <!-- Blocked Users Tab -->
  <div id="blocked" class="tab-content">
    <div class="section-header">
      <h2 class="section-title">Blocked Users</h2>
    </div>
    <div id="blocked-loading" class="loading">
      <div class="spinner"></div>
      <p>Loading blocked users...</p>
    </div>
    <div id="blocked-list" class="user-grid" style="display: none;"></div>
    <div id="blocked-empty" class="empty-state" style="display: none;">
      <h3>No Blocked Users</h3>
      <p>You haven't blocked anyone yet.</p>
    </div>
  </div>

  <!-- Find Friends Tab -->
  <div id="search" class="tab-content">
    <div class="section-header">
      <h2 class="section-title">Find Friends</h2>
      <div class="search-controls">
        <input type="text" id="searchInput" class="search-input" placeholder="Search by username or ID..." />
        <button class="btn btn-info" onclick="refreshAllUsers()">
          üîÑ Refresh
        </button>
        <button class="btn btn-primary" onclick="showAllUsersForFriendRequests()" style="margin-left: 10px;">
          üë• Show All Users
        </button>
      </div>
    </div>
    <div id="search-loading" class="loading">
      <div class="spinner"></div>
      <p>Loading users...</p>
    </div>
    <div id="search-list" class="user-grid" style="display: none;"></div>
    <div id="search-empty" class="empty-state" style="display: none;">
      <h3>No Users Found</h3>
      <p>Try adjusting your search or refresh to see all available users.</p>
    </div>
  </div>
</div>

<script>
// Global variables
let currentUserId = null;
let allUsers = [];
let friends = [];
let pendingRequests = [];
let blockedUsers = [];
let sentRequests = [];
let websocket = null;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;

// API Configuration
const API_BASE = 'http://localhost:4000/api';
const WS_URL = 'ws://localhost:4000/chat-notification';
const headers = {
  'Content-Type': 'application/json',
};

// Initialize the application
async function init() {
  try {
    // Get current user info
    const userResponse = await fetch(`${API_BASE}/user/me`);
    if (userResponse.ok) {
      const userData = await userResponse.json();
      currentUserId = userData.userId;
    }
  } 
  catch (error) 
  {
    console.error('Failed to get user info:', error);
    // Continue with default user ID
    currentUserId = 1;
  }

  // Initialize WebSocket connection
  initializeWebSocket();

  // Load initial data
  loadFriends();
  loadPendingRequests();
  loadBlockedUsers();
  loadAllUsers();
}

// WebSocket functionality
function initializeWebSocket() {
  updateConnectionStatus('connecting');
  
  try 
  {
    websocket = new WebSocket(WS_URL);
    
    websocket.onopen = function(event) {
      console.log('WebSocket connected');
      updateConnectionStatus('connected');
      reconnectAttempts = 0;
      
      // Send initial connection message with user ID if available
      // if (currentUserId) {
      //   websocket.send(JSON.stringify({
      //     type: 'connection',
      //     userId: currentUserId
      //   }));
      // }
      
      showNotification('Real-time notifications enabled! üéâ', 'websocket');
    };
    
    websocket.onmessage = function(event) 
    {
      try 
      {
        const data = JSON.parse(event.data);
        alert(JSON.stringify(data.message));
        handleWebSocketMessage(data);
      }
      catch (error) 
      {
        console.error('Failed to parse WebSocket message:', error);
      }
    };
    
    websocket.onclose = function(event) {
      console.log('WebSocket connection closed');
      updateConnectionStatus('disconnected');
      
      // Attempt to reconnect
      if (reconnectAttempts < maxReconnectAttempts) {
        setTimeout(() => {
          reconnectAttempts++;
          console.log(`Attempting to reconnect... (${reconnectAttempts}/${maxReconnectAttempts})`);
          initializeWebSocket();
        }, 2000 * reconnectAttempts); // Exponential backoff
      } else {
        showNotification('Unable to connect to real-time notifications', 'error');
      }
    };
    
    websocket.onerror = function(error) {
      console.error('WebSocket error:', error);
      updateConnectionStatus('disconnected');
    };
    
  } 
  catch (error) 
  {
    console.error('Failed to create WebSocket connection:', error);
    updateConnectionStatus('disconnected');
  }
}

function updateConnectionStatus(status) {
  const statusElement = document.getElementById('connectionStatus');
  
  switch (status) {
    case 'connected':
      statusElement.textContent = 'üü¢ Connected';
      statusElement.className = 'connection-status connected';
      break;
    case 'disconnected':
      statusElement.textContent = 'üî¥ Disconnected';
      statusElement.className = 'connection-status disconnected';
      break;
    case 'connecting':
      statusElement.textContent = 'üîÑ Connecting...';
      statusElement.className = 'connection-status connecting';
      break;
  }
}

function handleWebSocketMessage(data) 
{
  alert('Received WebSocket message:', data);
  handleFriendRequestNotification(data);
  
  switch (data.type) {
    case 'friend_request':
      handleFriendRequestNotification(data);
      break;
    case 'friend_request_accepted':
      handleFriendRequestAcceptedNotification(data);
      break;
    case 'friend_request_rejected':
      handleFriendRequestRejectedNotification(data);
      break;
    case 'friend_removed':
      handleFriendRemovedNotification(data);
      break;
    case 'user_blocked':
      handleUserBlockedNotification(data);
      break;
    case 'user_unblocked':
      handleUserUnblockedNotification(data);
      break;
    default:
      console.log('Unknown WebSocket message type:', data.type);
  }
}

function handleFriendRequestNotification(data) 
{
  showNotification(`üéâ ${`User ${data.from}`} sent you a ${data.message}`, 'websocket');
  
  // Refresh pending requests to show the new request
  loadPendingRequests();
  
  // Add visual highlight to pending tab
  highlightTab('pending');
  
  // Auto-switch to pending tab if user wants to see immediately
  // Uncomment the line below if you want auto-switching
  // switchTab('pending');
}

function handleFriendRequestAcceptedNotification(data) {
  showNotification(`‚úÖ ${data.accepterUsername || `User ${data.accepterId}`} accepted your friend request!`, 'success');
  
  // Refresh friends list to show new friend
  loadFriends();
  loadAllUsers(); // Update search results
  
  // Add visual highlight to friends tab
  highlightTab('friends');
}

function handleFriendRequestRejectedNotification(data) {
  showNotification(`‚ùå ${data.rejecterUsername || `User ${data.rejecterId}`} rejected your friend request`, 'info');
  
  // Refresh data to reflect changes
  loadAllUsers();
}

function handleFriendRemovedNotification(data) {
  showNotification(`üíî ${data.removerUsername || `User ${data.removerId}`} removed you from their friends`, 'info');
  
  // Refresh friends list
  loadFriends();
  loadAllUsers();
}

function handleUserBlockedNotification(data) {
  showNotification(`üö´ You have been blocked by ${data.blockerUsername || `User ${data.blockerId}`}`, 'info');
  
  // Refresh all data
  loadFriends();
  loadPendingRequests();
  loadAllUsers();
}

function handleUserUnblockedNotification(data) {
  showNotification(`üîì ${data.unblockerUsername || `User ${data.unblockerId}`} has unblocked you`, 'info');
  
  // Refresh data
  loadAllUsers();
}

function highlightTab(tabName) {
  const tab = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
  if (tab && !tab.classList.contains('active')) {
    tab.style.animation = 'pulseGlow 2s ease-in-out';
    setTimeout(() => {
      tab.style.animation = '';
    }, 2000);
  }
}

// Tab switching functionality
function switchTab(tabName) {
  // Hide all tab contents
  document.querySelectorAll('.tab-content').forEach(content => {
    content.classList.remove('active');
  });
  
  // Remove active class from all tabs
  document.querySelectorAll('.tab').forEach(tab => {
    tab.classList.remove('active');
  });
  
  // Show selected tab content
  document.getElementById(tabName).classList.add('active');
  
  // Add active class to clicked tab
  event.target.classList.add('active');
  
  // Reload data for the active tab
  switch(tabName) {
    case 'friends':
      loadFriends();
      break;
    case 'pending':
      loadPendingRequests();
      break;
    case 'blocked':
      loadBlockedUsers();
      break;
    case 'search':
      loadAllUsers();
      break;
  }
}

// API Helper Functions
async function apiCall(endpoint, options = {}) {
  try 
  {
    const response = await fetch(`${API_BASE}${endpoint}`, {
            headers,
            credentials: "include",
            ...options
            });

    
    const data = await response.json();
    
    if (!data.success) {
      throw new Error(data.message || 'API call failed');
    }
    
    return data;
  } 
  catch (error) 
  {
    console.error('API Error:', error);
    showNotification(error.message, 'error');
    throw error;
  }
}

// Load Functions
async function loadFriends() {
  const loadingEl = document.getElementById('friends-loading');
  const listEl = document.getElementById('friends-list');
  const emptyEl = document.getElementById('friends-empty');
  
  try 
  {
    loadingEl.style.display = 'block';
    listEl.style.display = 'none';
    emptyEl.style.display = 'none';
    
    const response = await apiCall('/friend/all');
    friends = response.data || [];
    
    loadingEl.style.display = 'none';
    
    if (friends.length === 0) {
      emptyEl.style.display = 'block';
    } else {
      listEl.style.display = 'grid';
      renderUsers(friends, listEl, 'friend');
    }
  } catch (error) {
    loadingEl.style.display = 'none';
    emptyEl.style.display = 'block';
  }
}

async function loadPendingRequests() 
{
  const loadingEl = document.getElementById('pending-loading');
  const listEl = document.getElementById('pending-list');
  const emptyEl = document.getElementById('pending-empty');
  
  try {
    loadingEl.style.display = 'block';
    listEl.style.display = 'none';
    emptyEl.style.display = 'none';
    
    const response = await apiCall('/friend/pending');
    pendingRequests = response.data || [];
    
    loadingEl.style.display = 'none';
    
    if (pendingRequests.length === 0) {
      emptyEl.style.display = 'block';
    } else {
      listEl.style.display = 'grid';
      renderUsers(pendingRequests, listEl, 'pending');
    }
  } catch (error) {
    loadingEl.style.display = 'none';
    emptyEl.style.display = 'block';
  }
}

async function loadBlockedUsers() {
  const loadingEl = document.getElementById('blocked-loading');
  const listEl = document.getElementById('blocked-list');
  const emptyEl = document.getElementById('blocked-empty');
  
  try {
    loadingEl.style.display = 'block';
    listEl.style.display = 'none';
    emptyEl.style.display = 'none';
    
    const response = await apiCall('/blocked/all');
    blockedUsers = response.data || [];
    
    loadingEl.style.display = 'none';
    
    if (blockedUsers.length === 0) {
      emptyEl.style.display = 'block';
    } else {
      listEl.style.display = 'grid';
      renderUsers(blockedUsers, listEl, 'blocked');
    }
  } catch (error) {
    loadingEl.style.display = 'none';
    emptyEl.style.display = 'block';
  }
}

async function loadAllUsers() {
  const loadingEl = document.getElementById('search-loading');
  const listEl = document.getElementById('search-list');
  const emptyEl = document.getElementById('search-empty');
  
  try {
    loadingEl.style.display = 'block';
    listEl.style.display = 'none';
    emptyEl.style.display = 'none';
    
    // Load all users - you might need to create this endpoint or modify existing one
    const response = await apiCall('/user/all');
    allUsers = response.data || [];
    
    // Filter out current user
    allUsers = allUsers.filter(user => user.userId !== currentUserId);
    
    loadingEl.style.display = 'none';
    
    if (allUsers.length === 0) {
      emptyEl.style.display = 'block';
    } else {
      listEl.style.display = 'grid';
      renderSearchUsers(allUsers, listEl);
    }
  } catch (error) {
    loadingEl.style.display = 'none';
    emptyEl.style.display = 'block';
  }
}

function refreshAllUsers() {
  loadAllUsers();
}

// Search functionality
function filterUsers() {
  const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
  const listEl = document.getElementById('search-list');
  const emptyEl = document.getElementById('search-empty');
  
  if (!searchTerm) {
    renderSearchUsers(allUsers, listEl);
    return;
  }
  
  const filteredUsers = allUsers.filter(user => {
    const username = (user.username || '').toLowerCase();
    const userId = user.userId.toString();
    return username.includes(searchTerm) || userId.includes(searchTerm);
  });
  
  if (filteredUsers.length === 0) {
    listEl.style.display = 'none';
    emptyEl.style.display = 'block';
  } else {
    emptyEl.style.display = 'none';
    listEl.style.display = 'grid';
    renderSearchUsers(filteredUsers, listEl);
  }
}

// Render users in the UI
function renderUsers(users, container, type) {
  container.innerHTML = '';
  
  users.forEach(user => {
    const userCard = createUserCard(user, type);
    container.appendChild(userCard);
  });
}

function renderSearchUsers(users, container) {
  container.innerHTML = '';
  
  users.forEach(user => {
    const userCard = createSearchUserCard(user);
    container.appendChild(userCard);
  });
}

function createUserCard(user, type) {
  const card = document.createElement('div');
  card.className = 'user-card';
  
  const avatar = (user.username  || 'User')[0].toUpperCase();
  const displayName = user.username  || `User ${String(user.userId)}`;
  const userIdStr = String(user.userId);
  
  let actions = '';
  
  switch(type) {
    case 'friend':
      actions = `
        <button class="btn btn-warning" onclick="blockUser('${userIdStr}')">
          üö´ Block
        </button>
        <button class="btn btn-danger" onclick="removeFriend('${userIdStr}')">
          ‚ùå Remove
        </button>
      `;
      break;
      
    case 'pending':
      actions = `
        <button class="btn btn-success" onclick="acceptFriendRequest('${userIdStr}')">
          ‚úÖ Accept
        </button>
        <button class="btn btn-danger" onclick="rejectFriendRequest('${userIdStr}')">
          ‚ùå Reject
        </button>
        <button class="btn btn-warning" onclick="blockUser('${userIdStr}')">
          üö´ Block
        </button>
      `;
      break;
      
    case 'blocked':
      actions = `
        <button class="btn btn-secondary" onclick="unblockUser('${userIdStr}')">
          üîì Unblock
        </button>
      `;
      break;
  }
  
  card.innerHTML = `
    <div class="user-info">
      <div class="user-avatar">${avatar}</div>
      <div class="user-details">
        <h3>${displayName}</h3>
        <p>User ID: ${userIdStr}</p>
        ${type === 'pending' ? '<span class="status-badge status-pending">Pending</span>' : ''}
        ${type === 'blocked' ? '<span class="status-badge status-blocked">Blocked</span>' : ''}
        ${type === 'friend' ? '<span class="status-badge status-accepted">Friends</span>' : ''}
      </div>
    </div>
    <div class="user-actions">
      ${actions}
    </div>
  `;
  
  return card;
}

function createSearchUserCard(user) {
  const card = document.createElement('div');
  card.className = 'user-card';
  
  const avatar = (user.username || 'User')[0].toUpperCase();
  const displayName = user.username || `User ${String(user.userId)}`;
  const userIdStr = String(user.userId);
  
  // Determine user status and appropriate actions
  const isFriend = friends.some(f => f.userId === user.userId);
  const isPending = pendingRequests.some(p => p.userId === user.userId);
  const isBlocked = blockedUsers.some(b => b.userId === user.userId);
  
  let statusBadge = '';
  let actions = '';
  
  if (isBlocked) {
    statusBadge = '<span class="status-badge status-blocked">Blocked</span>';
    actions = `
      <button class="btn btn-secondary" onclick="unblockUser('${userIdStr}')">
        üîì Unblock
      </button>
    `;
  } else if (isFriend) {
    statusBadge = '<span class="status-badge status-accepted">Friends</span>';
    actions = `
      <button class="btn btn-warning" onclick="blockUser('${userIdStr}')">
        üö´ Block
      </button>
      <button class="btn btn-danger" onclick="removeFriend('${userIdStr}')">
        ‚ùå Remove
      </button>
    `;
  } else if (isPending) {
    statusBadge = '<span class="status-badge status-pending">Request Sent</span>';
    actions = `
      <button class="btn btn-secondary" disabled>
        ‚è≥ Request Sent
      </button>
    `;
  } else {
    statusBadge = '<span class="status-badge status-available">Available</span>';
    actions = `
      <button class="btn btn-primary" onclick="sendFriendRequestToUser('${userIdStr}')">
        ‚ûï Send Request
      </button>
    `;
  }
  
  card.innerHTML = `
    <div class="user-info">
      <div class="user-avatar">${avatar}</div>
      <div class="user-details">
        <h3>${displayName}</h3>
        <p>User ID: ${userIdStr}</p>
        ${statusBadge}
      </div>
    </div>
    <div class="user-actions">
      ${actions}
    </div>
  `;
  
  return card;
}

// Friend Actions
async function sendFriendRequestToUser(receiverId) 
{
  try 
  {
    await apiCall('/friend/request', {
      method: 'POST',
      body: JSON.stringify({ receiverId: receiverId })
    });
    
    showNotification('Friend request sent successfully!', 'success');
    loadAllUsers(); // Refresh the search results
  } catch (error) {
    // Error already handled by apiCall
  }
}

async function acceptFriendRequest(senderId) {
  try {
    await apiCall('/friend/accept', {
      method: 'POST',
      body: JSON.stringify({ senderId })
    });
    
    showNotification('Friend request accepted!', 'success');
    loadPendingRequests();
    loadFriends();
    loadAllUsers(); // Refresh search to update status
  } catch (error) {
    // Error already handled by apiCall
  }
}

async function rejectFriendRequest(senderId) {
  try {
    await apiCall('/friend/reject', {
      method: 'POST',
      body: JSON.stringify({ senderId: senderId })
    });
    
    showNotification('Friend request rejected', 'success');
    loadPendingRequests();
    loadAllUsers(); // Refresh search to update status
  } catch (error) {
    // Error already handled by apiCall
  }
}

async function removeFriend(friendId) {
  if (!confirm('Are you sure you want to remove this friend?')) return;
  
  try {
    await apiCall(`/friend/${friendId}`, {
      method: 'DELETE'
    });
    
    showNotification('Friend removed successfully', 'success');
    loadFriends();
    loadAllUsers(); // Refresh search to update status
  } catch (error) {
    // Error already handled by apiCall
  }
}

async function blockUser(userId) 
{
  if (!confirm('Are you sure you want to block this user?')) return;
  
  try {
    await apiCall(`/blocked/${userId}`, {
      method: 'POST'
    });
    
    showNotification('User blocked successfully', 'success');
    loadBlockedUsers();
    loadFriends();
    loadPendingRequests();
    loadAllUsers(); // Refresh search to update status
  } catch (error) {
    // Error already handled by apiCall
  }
}

async function unblockUser(userId) {
  try {
    await apiCall(`/blocked/${userId}`, {
      method: 'DELETE'
    });
    
    showNotification('User unblocked successfully', 'success');
    loadBlockedUsers();
    loadAllUsers(); // Refresh search to update status
  } catch (error) {
    // Error already handled by apiCall
  }
}

// Notification system
function showNotification(message, type) {
  // Remove existing notifications
  document.querySelectorAll('.notification').forEach(n => n.remove());
  
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.textContent = message;
  
  document.body.appendChild(notification);
  
  // Show notification
  setTimeout(() => notification.classList.add('show'), 100);
  
  // Hide notification after 5 seconds for websocket notifications, 3 for others
  const hideTimeout = type === 'websocket' ? 5000 : 3000;
  setTimeout(() => {
    notification.classList.remove('show');
    setTimeout(() => notification.remove(), 300);
  }, hideTimeout);
}

// Initialize the application when page loads
document.addEventListener('DOMContentLoaded', init);

// Search functionality with debouncing
let searchTimeout;
document.addEventListener('DOMContentLoaded', () => {
  const searchInput = document.getElementById('searchInput');
  
  searchInput.addEventListener('input', () => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(filterUsers, 300); // Debounce search
  });
  
  searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      filterUsers();
    }
  });
});

async function showAllUsersForFriendRequests() {
  // Clear search input to show all users
  document.getElementById('searchInput').value = '';
  
  const loadingEl = document.getElementById('search-loading');
  const listEl = document.getElementById('search-list');
  const emptyEl = document.getElementById('search-empty');
  
  try {
    loadingEl.style.display = 'block';
    listEl.style.display = 'none';
    emptyEl.style.display = 'none';
    
    // Load all users using the same endpoint
    const response = await apiCall('/user/all');
    allUsers = response.data || [];
    
    // Filter out current user
    allUsers = allUsers.filter(user => user.userId !== currentUserId);
    
    loadingEl.style.display = 'none';
    
    if (allUsers.length === 0) {
      emptyEl.style.display = 'block';
    } else {
      listEl.style.display = 'grid';
      renderSearchUsers(allUsers, listEl);
      showNotification(`Showing ${allUsers.length} users available for friend requests`, 'info');
    }
  } catch (error) {
    loadingEl.style.display = 'none';
    emptyEl.style.display = 'block';
    showNotification('Failed to load users. Please try again.', 'error');
  }
}

// Clean up WebSocket connection when page is closed
window.addEventListener('beforeunload', () => {
  if (websocket) {
    websocket.close();
  }
});
</script>
</body>
</html>